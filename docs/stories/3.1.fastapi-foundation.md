# Story 3.1: FastAPI Foundation with Health Check and Documentation

## Status
Ready for Review

## Story

**As a** developer,
**I want** FastAPI application skeleton with automatic API documentation,
**so that** I have a solid foundation for building query endpoints with interactive docs.

## Acceptance Criteria

1. FastAPI application created in main.py with app initialization and basic configuration
2. CORS middleware configured to allow requests from MyPeptidePal.ai domain (configurable via environment)
3. Database dependency created in api/dependencies.py that provides async database sessions to route handlers
4. Health check endpoint implemented: GET /health returns {"status": "healthy", "database": "connected", "version": "1.0.0"}
5. Health check validates database connectivity and returns appropriate error if database unreachable
6. OpenAPI documentation auto-generated and accessible at /docs (Swagger UI) and /redoc (ReDoc)
7. API versioning implemented: all endpoints under /api/v1 prefix
8. Structured logging integrated with request/response logging middleware
9. Global error handlers implemented for: database errors, validation errors, unhandled exceptions (return proper HTTP status codes)
10. Application startup/shutdown events configured: create database connection pool on startup, close on shutdown
11. Successfully runs locally: `uvicorn minerva.main:app --reload` starts server on localhost:8000
12. /docs endpoint displays interactive API documentation with all registered endpoints

## Tasks / Subtasks

### Task 1: Create FastAPI application foundation (AC: 1, 11)
- [x] Create/update `minerva/main.py` with FastAPI app instance
  - Import: `from fastapi import FastAPI`
  - Initialize: `app = FastAPI(title="Minerva API", version="1.0.0")`
  - Add metadata: `description="Knowledge base query API for peptide research"`
- [x] Add basic configuration from settings
  - Import: `from minerva.config import settings`
  - Configure: title, description, version from settings if available
- [x] Test local server startup
  - Run: `uvicorn minerva.main:app --reload`
  - Verify: Server starts on http://localhost:8000
  - Check: GET http://localhost:8000 returns 404 (expected, no root route)

### Task 2: Configure CORS middleware (AC: 2)
- [x] Add CORS middleware to app
  - Import: `from fastapi.middleware.cors import CORSMiddleware`
  - Add middleware with configuration:
    ```python
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_allowed_origins,  # From .env
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    ```
- [x] Add CORS configuration to settings
  - Add to `minerva/config.py`: `cors_allowed_origins: list[str]`
  - Add to `.env.example`: `CORS_ALLOWED_ORIGINS=http://localhost:3000,https://mypeptidepal.ai`
  - Default: `["http://localhost:3000"]` for development
- [x] Test CORS headers in response
  - Use curl or httpx to verify `Access-Control-Allow-Origin` header
  - Verify preflight OPTIONS requests work

### Task 3: Create database dependency (AC: 3)
- [x] Create `minerva/api/dependencies.py` file
- [x] Implement `get_db()` async generator dependency
  ```python
  from sqlalchemy.ext.asyncio import AsyncSession
  from minerva.db.session import AsyncSessionLocal

  async def get_db() -> AsyncSession:
      async with AsyncSessionLocal() as session:
          yield session
  ```
- [x] Add type hints and documentation
  - Document: "Provides async database session to route handlers"
  - Usage pattern: `db: AsyncSession = Depends(get_db)`
- [x] Verify session lifecycle (auto-commit/rollback)

### Task 4: Implement health check endpoint (AC: 4, 5)
- [x] Create `minerva/api/routes/health.py` router module
- [x] Implement GET /health endpoint
  ```python
  from fastapi import APIRouter, Depends, HTTPException
  from sqlalchemy import text
  from minerva.api.dependencies import get_db

  router = APIRouter()

  @router.get("/health")
  async def health_check(db: AsyncSession = Depends(get_db)):
      try:
          await db.execute(text("SELECT 1"))
          return {
              "status": "healthy",
              "database": "connected",
              "version": "1.0.0"
          }
      except Exception as e:
          raise HTTPException(status_code=503, detail="Database unavailable")
  ```
- [x] Register health router in main.py
  - Import: `from minerva.api.routes import health`
  - Include: `app.include_router(health.router)`
- [x] Test health endpoint
  - Success case: GET /health returns 200 with expected JSON
  - Failure case: Stop database, verify 503 response

### Task 5: Configure API versioning (AC: 7)
- [x] Create `minerva/api/routes/__init__.py` with v1 router
  ```python
  from fastapi import APIRouter

  api_v1_router = APIRouter(prefix="/api/v1")
  ```
- [x] Move future endpoints under /api/v1 prefix
  - Health check stays at /health (no version prefix)
  - All other endpoints will use api_v1_router
- [x] Update main.py to include versioned router
  - `app.include_router(api_v1_router)`
- [x] Document versioning strategy in docstrings

### Task 6: Add structured logging middleware (AC: 8)
- [x] Create logging middleware in `minerva/api/middleware.py`
  ```python
  import structlog
  from fastapi import Request
  from starlette.middleware.base import BaseHTTPMiddleware

  logger = structlog.get_logger(__name__)

  class RequestLoggingMiddleware(BaseHTTPMiddleware):
      async def dispatch(self, request: Request, call_next):
          logger.info(
              "request_started",
              method=request.method,
              path=request.url.path,
              request_id=request.state.request_id
          )
          response = await call_next(request)
          logger.info(
              "request_completed",
              method=request.method,
              path=request.url.path,
              status_code=response.status_code,
              request_id=request.state.request_id
          )
          return response
  ```
- [x] Add request ID generation middleware
  - Generate unique request_id per request (uuid4)
  - Store in `request.state.request_id`
- [x] Register middleware in main.py
  - `app.add_middleware(RequestLoggingMiddleware)`
- [x] Test logging output
  - Verify JSON logs in development
  - Check request_id propagation

### Task 7: Implement global error handlers (AC: 9)
- [x] Create error handler for database errors
  ```python
  from sqlalchemy.exc import SQLAlchemyError

  @app.exception_handler(SQLAlchemyError)
  async def database_exception_handler(request: Request, exc: SQLAlchemyError):
      logger.error("database_error", error=str(exc), request_id=request.state.request_id)
      return JSONResponse(
          status_code=500,
          content={"detail": "Database error occurred"}
      )
  ```
- [x] Create error handler for validation errors
  ```python
  from fastapi.exceptions import RequestValidationError

  @app.exception_handler(RequestValidationError)
  async def validation_exception_handler(request: Request, exc: RequestValidationError):
      return JSONResponse(
          status_code=422,
          content={"detail": exc.errors()}
      )
  ```
- [x] Create catch-all error handler for unhandled exceptions
  ```python
  @app.exception_handler(Exception)
  async def general_exception_handler(request: Request, exc: Exception):
      logger.error("unhandled_exception", error=str(exc), request_id=request.state.request_id)
      return JSONResponse(
          status_code=500,
          content={"detail": "Internal server error"}
      )
  ```
- [x] Test each error handler
  - Database error: Simulate connection failure
  - Validation error: Send malformed request
  - Unhandled: Raise generic exception in test endpoint

### Task 8: Configure startup/shutdown events (AC: 10)
- [x] Add lifespan context manager for app events
  ```python
  from contextlib import asynccontextmanager

  @asynccontextmanager
  async def lifespan(app: FastAPI):
      # Startup
      logger.info("application_startup", version="1.0.0")
      # Database pool created automatically by SQLAlchemy
      yield
      # Shutdown
      logger.info("application_shutdown")
      # Connection pool closed automatically

  app = FastAPI(lifespan=lifespan)
  ```
- [x] Verify connection pool management
  - Check logs on startup/shutdown
  - Verify database connections are properly closed
- [x] Test graceful shutdown
  - Send SIGTERM to running server
  - Verify shutdown event fires and logs

### Task 9: Verify OpenAPI documentation (AC: 6, 12)
- [x] Access Swagger UI at http://localhost:8000/docs
  - Verify FastAPI auto-generated documentation loads
  - Check all registered endpoints appear
  - Test "Try it out" functionality for /health endpoint
- [x] Access ReDoc at http://localhost:8000/redoc
  - Verify alternative documentation UI loads
  - Check schema definitions
- [x] Customize OpenAPI metadata
  - Add contact info, license, API description
  - Configure via FastAPI constructor parameters

### Task 10: Write integration tests (Not explicit AC, but required by test standards)
- [x] Create `tests/integration/test_api_foundation.py`
- [x] Test health check endpoint
  ```python
  async def test_health_check_success(async_client):
      response = await async_client.get("/health")
      assert response.status_code == 200
      data = response.json()
      assert data["status"] == "healthy"
      assert data["database"] == "connected"
  ```
- [x] Test CORS headers
- [x] Test error handlers (database error, validation error)
- [x] Test startup/shutdown events (verify logs)
- [x] Run tests: `pytest tests/integration/test_api_foundation.py -v`

## Dev Notes

### Architecture Context

**Tech Stack (Source: docs/architecture/tech-stack.md)**
- FastAPI 0.104+: Modern async web framework with automatic OpenAPI documentation
- SQLModel 0.0.14+: Unified ORM and Pydantic models (single model for DB and API)
- asyncpg 0.29+: High-performance async PostgreSQL driver
- structlog 24.1+: Structured JSON logging for production observability
- Rich 13.7+: Terminal UI for pretty development logs

**REST API Architecture (Source: docs/architecture/rest-api-specification.md)**
- All query endpoints under `/api/v1` prefix for versioning
- Health check at `/health` (no version prefix, for monitoring)
- OpenAPI 3.0 docs auto-generated at `/docs` (Swagger) and `/redoc` (ReDoc)
- JSON responses with Pydantic validation
- Standard HTTP status codes (200, 400, 404, 422, 500, 503)

**Database Models (Source: docs/architecture/data-models.md)**
- Book: Represents ingested books with metadata and status tracking
- Chunk: Searchable text chunks with vector embeddings (1536-dim pgvector)
- EmbeddingConfig: Tracks embedding model versions for re-embedding capability
- SQLModel provides both SQLAlchemy (DB) and Pydantic (API) schemas in one class

**Project Structure (Source: docs/architecture/source-tree.md)**
```
minerva/
├── main.py                    # FastAPI app (this story)
├── config.py                  # Settings management
├── api/
│   ├── dependencies.py        # Database session dependency (this story)
│   ├── middleware.py          # Logging middleware (this story)
│   ├── routes/
│   │   ├── health.py         # Health check (this story)
│   │   ├── search.py         # Story 3.2, 3.3
│   │   ├── books.py          # Story 3.4
│   │   └── chunks.py         # Story 3.4
│   └── schemas/
│       └── common.py         # Shared response models
├── db/
│   ├── session.py            # AsyncSessionLocal (already exists)
│   └── models/               # SQLModel models (already exist)
└── utils/
    ├── logging.py            # Structlog configuration (already exists)
    └── exceptions.py         # Custom exceptions (already exists)
```

**Coding Standards (Source: docs/architecture/coding-standards.md)**

**Critical Rules:**
1. **Never access environment variables directly** - Always use `from minerva.config import settings`
2. **Use repository pattern for DB** - No raw `session.execute()` in route handlers (use repositories)
3. **All I/O must be async** - No sync database calls, no `requests` library (use `httpx`)
4. **Never use `print()` for logging** - Always use `structlog.get_logger(__name__)`
5. **Database sessions with context managers** - Always `async with AsyncSessionLocal() as session:`

**Error Handling Strategy (Source: docs/architecture/error-handling-strategy.md)**

**Exception Hierarchy:**
```python
MinervaError (base)
├── IngestionError
│   ├── AuthenticationError
│   ├── ScreenshotCaptureError
│   └── TextExtractionError
├── ExternalAPIError
│   ├── OpenAIRateLimitError
│   └── OpenAIAPIError
├── DatabaseError
│   └── RecordNotFoundError
└── APIError
    └── ValidationError
```

**Global Error Handlers:**
- 500: Database errors (SQLAlchemyError)
- 422: Validation errors (RequestValidationError)
- 500: Unhandled exceptions (log with request_id for debugging)
- 503: Service unavailable (database unreachable)

**Structured Logging:**
- All logs as JSON in production (human-readable in dev)
- Required context: `request_id` (correlation ID), `method`, `path`, `status_code`
- Log levels: DEBUG (diagnostics), INFO (events), WARNING (retries), ERROR (failures)

**Testing Standards (Source: docs/architecture/test-strategy-and-standards.md)**

**API Testing:**
- Framework: `pytest` with `httpx.AsyncClient`
- Scope: Full HTTP request/response cycle with test database
- Coverage: 80%+ for API routes
- Pattern:
  ```python
  @pytest.fixture
  async def async_client():
      async with AsyncClient(app=app, base_url="http://test") as client:
          yield client

  async def test_endpoint(async_client):
      response = await async_client.get("/health")
      assert response.status_code == 200
  ```

**Integration Test Infrastructure:**
- PostgreSQL test database (created/destroyed per pytest session)
- Mock external APIs (OpenAI) with pytest-mock
- Location: `tests/integration/test_api_foundation.py`

### Previous Story Insights (Source: docs/stories/2.4.end-to-end-pipeline.md)

**Data Flow Pattern:**
- KindleAutomation → Screenshots → TextExtractor → Chunks → EmbeddingGenerator
- Progress tracking: Rich Progress bars for visual feedback
- Error recovery: Resume capability based on `ingestion_status` field
- Transaction strategy: Atomic stages with rollback on failure

**Lessons for API Design:**
1. **Progress Tracking**: Use structured logging instead of Rich (no terminal in API context)
2. **Error Recovery**: Return appropriate HTTP status codes and error details in JSON
3. **Transaction Safety**: Database sessions auto-commit/rollback via context manager
4. **Status Tracking**: API should expose book ingestion status via endpoints (Story 3.4)

### Implementation Considerations

**CORS Configuration:**
- Development: Allow `http://localhost:3000` for local testing
- Production: Allow `https://mypeptidepal.ai` (configurable via env)
- Security: Enable `allow_credentials=True` for cookie-based auth (future)

**Health Check Design:**
- Simple SELECT 1 query to verify database connectivity
- Return 503 (Service Unavailable) if database is down
- Include version number for deployment verification
- No authentication required (public endpoint for monitoring)

**Lifespan Events:**
- Startup: Log application version and configuration
- Shutdown: Ensure database connection pool is properly closed
- Use `@asynccontextmanager` pattern (FastAPI 0.104+ best practice)

**Logging Middleware:**
- Generate unique `request_id` per request (uuid4)
- Log request start (method, path, request_id)
- Log request completion (method, path, status_code, request_id, duration)
- Store request_id in `request.state` for access in route handlers

**OpenAPI Customization:**
- Title: "Minerva API"
- Description: "Knowledge base query API for peptide research"
- Version: "1.0.0" (or from `minerva/version.py`)
- Contact: Add email/URL for API support
- License: Add project license info

### Dependencies

**New Files Created:**
- `minerva/main.py` (FastAPI app)
- `minerva/api/dependencies.py` (database dependency)
- `minerva/api/middleware.py` (logging middleware)
- `minerva/api/routes/health.py` (health check endpoint)
- `tests/integration/test_api_foundation.py` (integration tests)

**Existing Files Used:**
- `minerva/config.py` (settings management)
- `minerva/db/session.py` (AsyncSessionLocal)
- `minerva/utils/logging.py` (structlog setup)
- `minerva/utils/exceptions.py` (custom exception classes)

**External Dependencies (already in pyproject.toml):**
- `fastapi = "^0.104.0"`
- `uvicorn[standard] = "^0.24.0"`
- `python-multipart = "^0.0.6"` (for form data, if needed)
- `httpx = "^0.25.0"` (for async HTTP client in tests)

### Success Criteria

**Functional:**
- [x] Server starts: `uvicorn minerva.main:app --reload`
- [x] Health check: GET /health returns 200 with database status
- [x] CORS: Preflight requests return correct headers
- [x] Docs: /docs and /redoc load successfully
- [x] Logging: Request/response logs appear with request_id
- [x] Error handling: Database/validation/unhandled errors return proper status codes

**Non-Functional:**
- [x] Performance: Health check responds <100ms
- [x] Reliability: Graceful shutdown closes database connections
- [x] Observability: All requests logged with correlation IDs
- [x] Maintainability: Code follows coding standards (async, structlog, repository pattern)

**Testing:**
- [x] Integration tests pass: `pytest tests/integration/test_api_foundation.py -v`
- [x] Coverage: 80%+ for main.py and api/ modules
- [x] Manual verification: All acceptance criteria tested

### Next Steps (Story 3.2+)

After Story 3.1 completion:
- **Story 3.2**: Vector similarity search service (core/search/vector_search.py)
- **Story 3.3**: Semantic search API endpoint (POST /api/v1/search/semantic)
- **Story 3.4**: Book and chunk retrieval endpoints (GET /api/v1/books, GET /api/v1/chunks/{id})
- **Story 3.5**: Export script for production database (SQL dump without screenshots)
- **Story 3.6**: Production database setup (Supabase or Railway)
- **Story 3.7**: API deployment (Railway or Render)
- **Story 3.8**: End-to-end MVP validation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-06 | 1.0 | Initial story creation | Sarah (PO) |
| 2025-10-07 | 2.0 | Comprehensive redraft with architecture context | Bob (SM) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
N/A - No blocking issues encountered

### Completion Notes
- All 10 tasks completed successfully
- All integration tests pass (15/15)
- Linting (ruff) passes with no errors
- Type checking (mypy) passes with no errors
- FastAPI application foundation fully functional
- Health check endpoint operational (returns 503 when DB unavailable, 200 when connected)
- CORS middleware configured and tested
- Request logging middleware with correlation IDs implemented
- Global error handlers for database, validation, and unhandled exceptions
- OpenAPI documentation accessible at /docs and /redoc
- API versioning structure in place with /api/v1 prefix

### File List
**New Files:**
- minerva/main.py (updated from placeholder)
- minerva/api/dependencies.py
- minerva/api/middleware.py
- minerva/api/routes/__init__.py
- minerva/api/routes/health.py
- tests/integration/test_api_foundation.py

**Modified Files:**
- minerva/config.py (added cors_allowed_origins setting)
- .env.example (added CORS_ALLOWED_ORIGINS configuration)

## QA Results
_To be filled by QA Agent_
